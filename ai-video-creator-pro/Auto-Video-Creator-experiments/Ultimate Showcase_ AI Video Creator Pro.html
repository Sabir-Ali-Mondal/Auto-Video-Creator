<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ultimate Showcase: AI Video Creator Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700;800&display=swap" rel="stylesheet">
    <!-- p5.js Library Included -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-start: #0f172a; --bg-end: #312e81; --text-light: #e0e7ff;
            --accent-glow: #f472b6; --accent-bright: #38bdf8;
            --correct-color: #10b981; --incorrect-color: #ef4444;
        }
        body { font-family: 'Manrope', system-ui, sans-serif; background-color: var(--bg-start); margin: 0; padding: 1rem; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; text-align: center; }
        .container { max-width: 900px; width: 100%; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(15px); padding: 2rem; border-radius: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        .canvas-wrapper { position: relative; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border-radius: 0.75rem; overflow: hidden; }
        canvas { width: 100%; height: auto; background-color: var(--bg-start); aspect-ratio: 16 / 9; display: block; }
        h1 { color: #fff; font-weight: 800; text-shadow: 0 0 15px var(--accent-glow); margin-top: 0; }
        p { color: #c7d2fe; }
        
        #controls { display: flex; align-items: center; justify-content: center; gap: 1.5rem; margin-top: 1.5rem; }
        
        #playPauseBtn { font-family: 'Manrope', sans-serif; font-size: 1.1rem; padding: 0.8rem; width: 60px; height: 60px; background-image: linear-gradient(to right, var(--accent-glow), var(--accent-bright)); color: white; border: none; border-radius: 50%; cursor: pointer; transition: all 0.2s ease; font-weight: 700; box-shadow: 0 0 25px rgba(244, 114, 182, 0.5); display: flex; align-items: center; justify-content: center; }
        #playPauseBtn:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 6px 30px rgba(244, 114, 182, 0.7); }
        #playPauseBtn:disabled { background: #4b5563; cursor: not-allowed; transform: none; box-shadow: none; opacity: 0.5; }
        #playPauseBtn svg { width: 28px; height: 28px; }

        #progressBar { flex-grow: 1; height: 10px; background-color: rgba(255,255,255,0.1); border-radius: 5px; cursor: pointer; position: relative; }
        #progressFill { height: 100%; width: 0%; background-image: linear-gradient(to right, var(--accent-bright), var(--accent-glow)); border-radius: 5px; box-shadow: 0 0 15px var(--accent-bright); }
        #status { margin-top: 1rem; color: #a5b4fc; font-size: 0.9rem; height: 1.2em; }

        #loadingOverlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 10; transition: opacity 0.5s ease; }
        .loading-spinner { width: 4rem; height: 4rem; border: 0.3rem solid transparent; border-top-color: var(--accent-bright); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loadingText { margin-top: 1.5rem; font-size: 1.1rem; font-weight: 700; }
        #p5_container { position: absolute; top: -9999px; left: -9999px; } /* For offscreen p5 canvases */
    </style>
</head>
<body>

    <div class="container">
        <h1>AI Video Creator Pro</h1>
        <p>This interactive demo renders a video from a JSON script, including narration, charts, tables, custom 2D/3D sketches, and an automated quiz.</p>
        <div class="canvas-wrapper">
            <canvas id="demoCanvas" width="1280" height="720"></canvas>
            <div id="loadingOverlay">
                <div class="loading-spinner"></div>
                <div id="loadingText">Preparing Showcase...</div>
            </div>
        </div>
        <div id="controls">
            <button id="playPauseBtn" disabled>
                <svg id="playIcon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                <svg id="pauseIcon" viewBox="0 0 24 24" fill="currentColor" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
            </button>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <p id="status">Please wait, preparing the experience...</p>
    </div>
    <div id="p5_container"></div>

<script>
const showcaseJson = {
  "width": 1280, "height": 720,
  "scenes": [
    { "id": "title", "type": "title", "text": "AI Video Creator Pro", "narration": "Welcome to the future of video creation. A world where your ideas are brought to life, instantly, through the power of code.", "voiceGender": "female" },
    { "id": "paragraph", "type": "paragraph", "text": "Beyond Complexity", "narration": "Traditional video editing is a maze of timelines and complex software. We believe creation should be as simple as writing down your thoughts. This tool makes that a reality.", "bgUrl": "https://images.unsplash.com/photo-1522204523234-8729aa6e3d54?w=1280&auto=format&fit=crop&q=80", "voiceGender": "male" },
    { "id": "html_content", "type": "html_content", "text": "Your Vision, as Code", "narration": "At its core is a simple yet powerful idea: describe your video with JSON. Define scenes, text, and data, and our engine transforms it into a dynamic, animated story.", "bgUrl": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=1280&auto=format&fit=crop&q=80", "voiceGender": "female" },
    { "id": "bullet_points", "type": "bullet_points", "text": "A Universe of Features", "narration": "This tool is packed with everything you need. Create stunning data visualizations, present clear data tables, run custom p5.js sketches, or even render 3D scenes with WebGL.", "points": [ "Animated Charts & Tables", "Podcast-Style Narration", "P5.js 2D/3D Sketches", "Interactive Quizzes" ], "bgUrl": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=1280&auto=format&fit=crop&q=80", "voiceGender": "male" },
    { "id": "chart_scene", "type": "chart", "text": "Visualize Your Data", "narration": "Bring your data to life. Bar charts are perfect for comparing values and showing growth over time, all animated beautifully without any extra effort.", "chartData": [ { "label": "Q1", "value": 65 }, { "label": "Q2", "value": 78 }, { "label": "Q3", "value": 92 }, { "label": "Q4", "value": 85 } ], "bgUrl": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=1280&auto=format&fit=crop&q=80", "voiceGender": "female" },
    { "id": "performance_table", "type": "table", "text": "Present Data Clearly", "narration": "For more detailed information, the table scene provides a clean, professional layout to compare features or present structured data in an easy-to-read format.", "tableHeaders": ["Feature", "Availability", "Best For"], "tableData": [ ["Bar Charts", "Available", "Comparisons"], ["Pie Charts", "Available", "Proportions"], ["P5.js Scenes", "Available", "Custom Graphics"] ], "bgUrl": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=1280&auto=format&fit=crop&q=80", "voiceGender": "male" },
    { "id": "network_vis", "type": "network", "text": "Connected Ecosystem", "narration": "Modern solutions thrive on interconnectivity. This network visualization shows how different components work together seamlessly to create powerful results.", "nodes": ["API", "Database", "Frontend", "AI Engine", "Storage"], "voiceGender": "female" },
    { "id": "timeline_demo", "type": "timeline", "text": "Evolution Timeline", "narration": "Progress happens in stages. Here's how technology has evolved from simple concepts to sophisticated AI-powered systems that transform entire industries.", "events": [{"year": "2010", "title": "Web 2.0"}, {"year": "2015", "title": "Mobile First"}, {"year": "2020", "title": "AI Integration"}, {"year": "2025", "title": "Code Generation"}], "voiceGender": "male" },
    { "id": "comparison", "type": "comparison", "text": "Traditional vs Modern", "narration": "The difference is striking. Traditional methods require extensive manual work, while modern AI-powered approaches deliver results instantly with just simple instructions.", "leftTitle": "Traditional", "rightTitle": "AI-Powered", "leftPoints": ["Complex Tools", "Hours of Work", "Technical Skills"], "rightPoints": ["Simple Input", "Instant Results", "No Experience Needed"], "voiceGender": "female" },
    { "id": "p5_chair", "type": "p5_js", "sketch": "chair", "text": "Custom 2D Sketches", "narration": "For complete creative freedom, you can embed p5.js sketches. This allows for generative art, custom diagrams, or unique visual styles, rendered right inside your video.", "voiceGender": "female" },
    { "id": "p5_atom", "type": "p5_js_3d", "sketch": "atom_3d", "renderer": "webgl", "duration": 5000, "text": "3D with WebGL", "narration": "The engine also supports WebGL for hardware-accelerated 3D graphics, perfect for product showcases, scientific visualizations, or abstract animations.", "voiceGender": "male" },
    { "id": "quiz", "type": "quiz", "narration": "Let's finish with a quick question to review. What is the core technology used to define the video's structure? Is it A: HTML... B: JSON... C: Python... or D: CSS?", "question": "What technology defines the video's structure?", "options": ["HTML", "JSON", "Python", "CSS"], "correctAnswer": 1, "answerText": "JSON", "voiceGender": "female" },
    { "id": "end", "type": "end", "text": "Create Your Story", "narration": "The power to create is now at your fingertips. What story will you tell? Thank you.", "bgUrl": "https://images.unsplash.com/photo-1534723328310-e82dad3ee43f?w=1280&auto=format&fit=crop&q=80", "voiceGender": "female" }
  ]
};

// --- Global State & Elements ---
const elements = { 
    canvas: document.getElementById('demoCanvas'), ctx: document.getElementById('demoCanvas').getContext('2d'), statusEl: document.getElementById('status'), 
    playPauseBtn: document.getElementById('playPauseBtn'), playIcon: document.getElementById('playIcon'), pauseIcon: document.getElementById('pauseIcon'),
    progressBar: document.getElementById('progressBar'), progressFill: document.getElementById('progressFill'),
    loadingOverlay: document.getElementById('loadingOverlay'), loadingText: document.getElementById('loadingText'),
    p5Container: document.getElementById('p5_container')
};
let state = { isRunning: false, isPaused: false, masterTimelineStart: 0, pausedTime: 0, totalDuration: 0, currentSceneIndex: -1, rafId: null, images: new Map(), particles: [], maleVoices: [], femaleVoices: [] };
const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

// --- P5.js Integration Manager ---
const p5Manager = {
    instances: new Map(),
    getSketch(scene) {
        const id = scene.sketch + (scene.renderer || '2d');
        if (!this.instances.has(id)) {
            const sketchFn = this.sketches[scene.sketch];
            if (sketchFn) {
                const instance = new p5(sketchFn, this.createContainer(id));
                instance.progress = 0; // Custom property to sync with timeline
                this.instances.set(id, instance);
            }
        }
        return this.instances.get(id);
    },
    createContainer(id) {
        const div = document.createElement('div');
        div.id = `p5_instance_${id}`;
        div.style.position = 'absolute';
        div.style.top = '-9999px';
        div.style.left = '-9999px';
        elements.p5Container.appendChild(div);
        return div;
    },
    sketches: {
        chair: (p) => {
            p.setup = () => { 
                p.createCanvas(1280, 720); 
                p.noLoop(); 
                p.strokeWeight(8); 
                p.stroke(224, 231, 255); 
                p.noFill(); 
            };
            p.draw = () => { 
                p.background(0, 0, 0, 0); // Transparent background
                p.translate(p.width/2, p.height/2); // Center the drawing
                p.scale(0.8); // Make it fit better
                p.translate(-300, -150); // Adjust position
                p.rect(0, 250, 600, 20); 
                p.line(0, 250, 0, 0); 
                p.line(600, 250, 600, 0); 
                p.line(0, 0, 600, 0); 
                p.line(100, 250, 100, 450); 
                p.line(500, 250, 500, 450); 
            };
        },
        atom_3d: (p) => {
            let angle = 0;
            p.setup = () => { 
                p.createCanvas(1280, 720, p.WEBGL); 
                p.noStroke(); 
            };
            p.draw = () => {
                p.background(0, 0, 0, 0); // Transparent background
                p.ambientLight(100);
                p.pointLight(255, 255, 255, 0, 0, 200);
                
                // Scale everything to fit within canvas bounds
                p.push();
                p.scale(0.8); // Scale down to ensure it fits
                p.rotateY(p.progress * Math.PI * 2);
                p.specularMaterial(250, 0, 0);
                p.sphere(80);
                p.pop();
                
                for (let i = 0; i < 3; i++) {
                    p.push();
                    p.scale(0.8);
                    p.rotateX(i * Math.PI / 3 + p.progress * Math.PI);
                    p.rotateZ(i * Math.PI / 5);
                    p.torus(200, 5, 50, 3); // Smaller torus
                    p.translate(200, 0, 0); // Smaller radius
                    p.specularMaterial(0, 0, 250);
                    p.sphere(20);
                    p.pop();
                }
            };
        }
    }
};

// --- Main Control Flow ---
function play() { if (state.isRunning && !state.isPaused) return; state.isRunning = true; state.isPaused = false; elements.playIcon.style.display = 'none'; elements.pauseIcon.style.display = 'block'; if (state.pausedTime > 0) { state.masterTimelineStart += (performance.now() - state.pausedTime); } else { state.masterTimelineStart = performance.now(); } speechSynthesis.resume(); if (!state.rafId) state.rafId = requestAnimationFrame(mainLoop); }
function pause() { if (!state.isRunning || state.isPaused) return; state.isPaused = true; elements.playIcon.style.display = 'block'; elements.pauseIcon.style.display = 'none'; state.pausedTime = performance.now(); speechSynthesis.pause(); cancelAnimationFrame(state.rafId); state.rafId = null; }
function seek(e) { const rect = elements.progressBar.getBoundingClientRect(); const percent = (e.clientX - rect.left) / rect.width; const seekTime = state.totalDuration * percent; state.masterTimelineStart = performance.now() - seekTime; if(state.isPaused) { state.pausedTime = state.masterTimelineStart + seekTime; } speechSynthesis.cancel(); mainLoop(performance.now()); if(!state.isPaused) { if (!state.rafId) requestAnimationFrame(mainLoop); } }
function endShowcase() { cancelAnimationFrame(state.rafId); state.rafId = null; state.isRunning = false; state.isPaused = false; state.pausedTime = 0; elements.playIcon.style.display = 'block'; elements.pauseIcon.style.display = 'none'; elements.statusEl.textContent = "Showcase complete! Click play to restart."; state.masterTimelineStart = performance.now() - state.totalDuration; mainLoop(performance.now()); }

// --- Main Animation Loop ---
function mainLoop(timestamp) { if (!state.isRunning || state.isPaused) { state.rafId = null; return; } const elapsed = timestamp - state.masterTimelineStart; let newSceneIndex = -1; for (let i = 0; i < showcaseJson.scenes.length; i++) { if (elapsed < showcaseJson.scenes[i].startTime + showcaseJson.scenes[i].duration) { newSceneIndex = i; break; } } if (newSceneIndex === -1 || elapsed >= state.totalDuration) { endShowcase(); return; } if (newSceneIndex !== state.currentSceneIndex) { state.currentSceneIndex = newSceneIndex; const scene = showcaseJson.scenes[newSceneIndex]; elements.statusEl.textContent = `Playing Scene: ${scene.id}`; speechSynthesis.cancel(); const utterance = new SpeechSynthesisUtterance(scene.narration); const voicePool = scene.voiceGender === 'male' ? state.maleVoices : state.femaleVoices; if (voicePool.length > 0) utterance.voice = voicePool[Math.floor(Math.random() * voicePool.length)]; utterance.pitch = scene.pitch || 1.0; speechSynthesis.speak(utterance); } const scene = showcaseJson.scenes[state.currentSceneIndex]; const sceneElapsed = elapsed - scene.startTime; const progress = Math.min(sceneElapsed / scene.duration, 1.0); elements.progressFill.style.width = `${(elapsed / state.totalDuration) * 100}%`; draw(scene, progress); state.rafId = requestAnimationFrame(mainLoop); }

// --- Master Drawing Engine ---
function draw(scene, progress) { const { ctx, canvas } = elements; const bgGradient = ctx.createLinearGradient(0, 0, canvas.width, 0.75 * canvas.height); bgGradient.addColorStop(0, '#312e81'); bgGradient.addColorStop(1, '#0f172a'); ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, canvas.width, canvas.height); drawParticles(); const bgImg = state.images.get(scene.bgUrl); if (bgImg?.complete) { ctx.globalAlpha = 0.15; const hRatio = canvas.width / bgImg.width; const vRatio = canvas.height / bgImg.height; const ratio = Math.max(hRatio, vRatio); const centerX = (canvas.width - bgImg.width * ratio) / 2; const centerY = (canvas.height - bgImg.height * ratio) / 2; ctx.drawImage(bgImg, 0, 0, bgImg.width, bgImg.height, centerX, centerY, bgImg.width * ratio, bgImg.height * ratio); } const fadeIn = Math.min(1, easeOutCubic(progress) * 4); ctx.globalAlpha = fadeIn; const drawFns = { title, paragraph, bullet_points, p5_js: drawP5Scene, p5_js_3d: drawP5Scene, chart, pie_chart, table, html_content, quiz, end, network, timeline, comparison }; (drawFns[scene.type] || title)(scene, progress); ctx.globalAlpha = 1.0; }
function createParticles() { for (let i = 0; i < 50; i++) state.particles.push({ x: Math.random() * 1280, y: Math.random() * 720, r: Math.random() * 2.5 + 0.5, a: Math.random() * 0.3 + 0.1, s: Math.random() * 0.3 + 0.1 }); }
function drawParticles() { const { ctx } = elements; ctx.fillStyle = '#ffffff'; state.particles.forEach(p => { p.y -= p.s; if (p.y < 0) p.y = 720; ctx.globalAlpha = p.a; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0; }
function drawWithGlow(drawCommands, glowColor = '#f472b6', blur = 20) { const { ctx } = elements; ctx.shadowColor = glowColor; ctx.shadowBlur = blur; drawCommands(); ctx.shadowBlur = 0; }
function wrapText(text, maxWidth) { const words = text.split(' '); let lines = [], currentLine = words[0] || ''; for (let i = 1; i < words.length; i++) { const testLine = `${currentLine} ${words[i]}`; if (elements.ctx.measureText(testLine).width < maxWidth) currentLine = testLine; else { lines.push(currentLine); currentLine = words[i]; } } lines.push(currentLine); return lines; }
function drawRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.arcTo(x + width, y, x + width, y + radius, radius); ctx.lineTo(x + width, y + height - radius); ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius); ctx.lineTo(x + radius, y + height); ctx.arcTo(x, y + height, x, y + height - radius, radius); ctx.lineTo(x, y + radius); ctx.arcTo(x, y, x + radius, y, radius); ctx.closePath(); }

// --- Animated Scene Drawing Functions ---
function title(scene, progress) { const { ctx, canvas } = elements; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const eased = easeOutCubic(progress); drawWithGlow(() => { ctx.font = `800 ${90 * eased}px Manrope`; ctx.fillStyle = 'rgba(255, 255, 255, 0.95)'; ctx.fillText(scene.text, canvas.width / 2, canvas.height / 2); }); }
function end(scene, progress) { title(scene, progress); }
function paragraph(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.textAlign = 'center'; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.globalAlpha = Math.min(1, eased * 3); ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.3); ctx.font = '400 32px Manrope'; ctx.fillStyle = 'rgba(224, 231, 255, 0.85)'; const lines = wrapText(scene.narration, canvas.width * 0.7); lines.forEach((line, i) => { const lineProgress = Math.max(0, Math.min(1, (eased - i * 0.1) / 0.5)); ctx.globalAlpha = lineProgress; ctx.fillText(line, canvas.width / 2, canvas.height * 0.5 + i * 50); }); ctx.globalAlpha = 1.0; }
function bullet_points(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.textAlign = 'center'; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.2); ctx.font = '700 32px Manrope'; ctx.textAlign = 'left'; scene.points.forEach((point, i) => { const pointProgress = Math.max(0, Math.min(1, (eased - 0.1 - i * 0.2) / 0.5)); if (pointProgress > 0) { ctx.globalAlpha = pointProgress; const y = canvas.height * 0.4 + i * 80; ctx.fillStyle = '#38bdf8'; ctx.fillText('✓', canvas.width * 0.2, y); ctx.fillStyle = '#e0e7ff'; ctx.fillText(point, canvas.width * 0.2 + 50, y); } }); ctx.globalAlpha = 1.0; }
function html_content(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.save(); const card = { w: 600, h: 250, r: 20 }; const scale = eased; const opacity = eased; const rotation = (1 - eased) * -5 * Math.PI / 180; ctx.globalAlpha = opacity; ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(rotation); ctx.scale(scale, scale); ctx.translate(-card.w / 2, -card.h / 2); const gradient = ctx.createLinearGradient(0, 0, card.w, card.h); gradient.addColorStop(0, '#6d28d9'); gradient.addColorStop(1, '#be185d'); ctx.fillStyle = gradient; drawWithGlow(() => { drawRoundRect(ctx, 0, 0, card.w, card.h, card.r); ctx.fill(); }, '#be185d', 30); ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '800 40px Manrope'; ctx.fillText('✨ JSON → Mōtion', card.w / 2, card.h * 0.4); ctx.font = '400 20px Manrope'; ctx.globalAlpha = opacity * 0.9; const lines = wrapText("The universal language of data, now the language of video creation.", card.w * 0.8); lines.forEach((line, i) => ctx.fillText(line, card.w / 2, card.h * 0.65 + i * 25)); ctx.restore(); }

// --- New Scene Types ---
function network(scene, progress) {
    const { ctx, canvas } = elements;
    const eased = easeOutCubic(progress);
    
    ctx.textAlign = 'center';
    ctx.font = '800 50px Manrope';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15);
    
    const nodes = scene.nodes || [];
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) * 0.25;
    
    // Draw connections first
    ctx.globalAlpha = Math.min(1, eased * 2);
    ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
    ctx.lineWidth = 2;
    
    for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
            const connectionProgress = Math.max(0, Math.min(1, (eased - 0.2 - (i + j) * 0.05) / 0.6));
            if (connectionProgress > 0) {
                const angle1 = (i / nodes.length) * 2 * Math.PI;
                const angle2 = (j / nodes.length) * 2 * Math.PI;
                const x1 = centerX + Math.cos(angle1) * radius;
                const y1 = centerY + Math.sin(angle1) * radius;
                const x2 = centerX + Math.cos(angle2) * radius;
                const y2 = centerY + Math.sin(angle2) * radius;
                
                ctx.globalAlpha = connectionProgress * 0.3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
    }
    
    // Draw nodes
    nodes.forEach((node, i) => {
        const nodeProgress = Math.max(0, Math.min(1, (eased - 0.1 - i * 0.1) / 0.5));
        if (nodeProgress > 0) {
            const angle = (i / nodes.length) * 2 * Math.PI;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            ctx.globalAlpha = nodeProgress;
            
            // Node circle
            const nodeRadius = 40 * nodeProgress;
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, nodeRadius);
            gradient.addColorStop(0, '#f472b6');
            gradient.addColorStop(1, '#38bdf8');
            ctx.fillStyle = gradient;
            
            drawWithGlow(() => {
                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                ctx.fill();
            }, '#f472b6', 15);
            
            // Node label
            ctx.fillStyle = '#fff';
            ctx.font = '700 18px Manrope';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node, x, y);
        }
    });
    
    ctx.globalAlpha = 1.0;
}

function timeline(scene, progress) {
    const { ctx, canvas } = elements;
    const eased = easeOutCubic(progress);
    
    ctx.textAlign = 'center';
    ctx.font = '800 50px Manrope';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15);
    
    const events = scene.events || [];
    const timelineY = canvas.height / 2;
    const startX = canvas.width * 0.15;
    const endX = canvas.width * 0.85;
    const timelineWidth = endX - startX;
    
    // Draw timeline line
    const lineProgress = Math.min(1, eased * 2);
    ctx.globalAlpha = lineProgress;
    ctx.strokeStyle = '#38bdf8';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(startX, timelineY);
    ctx.lineTo(startX + timelineWidth * lineProgress, timelineY);
    ctx.stroke();
    
    // Draw events
    events.forEach((event, i) => {
        const eventProgress = Math.max(0, Math.min(1, (eased - 0.2 - i * 0.15) / 0.6));
        if (eventProgress > 0) {
            const x = startX + (i / (events.length - 1)) * timelineWidth;
            
            ctx.globalAlpha = eventProgress;
            
            // Event dot
            const dotRadius = 15 * eventProgress;
            ctx.fillStyle = '#f472b6';
            drawWithGlow(() => {
                ctx.beginPath();
                ctx.arc(x, timelineY, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }, '#f472b6', 10);
            
            // Year label
            ctx.fillStyle = '#38bdf8';
            ctx.font = '700 24px Manrope';
            ctx.textAlign = 'center';
            ctx.fillText(event.year, x, timelineY - 50);
            
            // Title label
            ctx.fillStyle = '#e0e7ff';
            ctx.font = '400 20px Manrope';
            ctx.fillText(event.title, x, timelineY + 50);
        }
    });
    
    ctx.globalAlpha = 1.0;
}

function comparison(scene, progress) {
    const { ctx, canvas } = elements;
    const eased = easeOutCubic(progress);
    
    ctx.textAlign = 'center';
    ctx.font = '800 50px Manrope';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15);
    
    const leftTitle = scene.leftTitle || "Before";
    const rightTitle = scene.rightTitle || "After";
    const leftPoints = scene.leftPoints || [];
    const rightPoints = scene.rightPoints || [];
    
    // Split screen effect
    const splitProgress = Math.min(1, eased * 3);
    
    // Left side
    ctx.globalAlpha = splitProgress;
    const leftX = canvas.width * 0.25;
    const rightX = canvas.width * 0.75;
    
    // Left panel
    ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
    ctx.fillRect(0, canvas.height * 0.25, canvas.width / 2, canvas.height * 0.6);
    
    // Right panel
    ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
    ctx.fillRect(canvas.width / 2, canvas.height * 0.25, canvas.width / 2, canvas.height * 0.6);
    
    // Divider line
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, canvas.height * 0.25);
    ctx.lineTo(canvas.width / 2, canvas.height * 0.85);
    ctx.stroke();
    
    // Left title
    ctx.fillStyle = '#ef4444';
    ctx.font = '700 36px Manrope';
    ctx.fillText(leftTitle, leftX, canvas.height * 0.35);
    
    // Right title
    ctx.fillStyle = '#10b981';
    ctx.fillText(rightTitle, rightX, canvas.height * 0.35);
    
    // Left points
    ctx.font = '400 24px Manrope';
    ctx.textAlign = 'center';
    leftPoints.forEach((point, i) => {
        const pointProgress = Math.max(0, Math.min(1, (eased - 0.3 - i * 0.1) / 0.5));
        if (pointProgress > 0) {
            ctx.globalAlpha = pointProgress;
            ctx.fillStyle = '#fca5a5';
            ctx.fillText(`✗ ${point}`, leftX, canvas.height * 0.5 + i * 40);
        }
    });
    
    // Right points
    rightPoints.forEach((point, i) => {
        const pointProgress = Math.max(0, Math.min(1, (eased - 0.3 - i * 0.1) / 0.5));
        if (pointProgress > 0) {
            ctx.globalAlpha = pointProgress;
            ctx.fillStyle = '#6ee7b7';
            ctx.fillText(`✓ ${point}`, rightX, canvas.height * 0.5 + i * 40);
        }
    });
    
    ctx.globalAlpha = 1.0;
}

function chart(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.textAlign = 'center'; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15); const data = scene.chartData || []; const area = { x: canvas.width * 0.15, y: canvas.height * 0.25, w: canvas.width * 0.7, h: canvas.height * 0.5 }; const maxVal = Math.max(...data.map(d => d.value)); const barWidth = area.w / (data.length * 1.5); data.forEach((item, i) => { const itemProgress = Math.max(0, Math.min(1, (eased - i * 0.1) / 0.6)); const barHeight = (item.value / maxVal) * area.h * itemProgress; const x = area.x + (i * barWidth * 1.5); const y = area.y + area.h - barHeight; const gradient = ctx.createLinearGradient(x, y, x, y + barHeight); gradient.addColorStop(0, '#38bdf8'); gradient.addColorStop(1, '#f472b6'); ctx.fillStyle = gradient; drawWithGlow(() => ctx.fillRect(x, y, barWidth, barHeight), '#38bdf8'); ctx.fillStyle = '#c7d2fe'; ctx.font = `700 20px Manrope`; ctx.globalAlpha = itemProgress; ctx.fillText(item.label, x + barWidth / 2, area.y + area.h + 30); ctx.globalAlpha = 1.0; }); }
function pie_chart(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.textAlign = 'center'; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15); const data = scene.pieData || []; const total = data.reduce((s, i) => s + i.value, 0); const cx = canvas.width / 2, cy = canvas.height / 2 + 50, r = Math.min(canvas.width, canvas.height) / 4.5; const colors = ['#f472b6', '#38bdf8', '#34d399', '#f59e0b', '#ef4444']; let currentAngle = -0.5 * Math.PI; const angleToDraw = 2 * Math.PI * eased; data.forEach((item, i) => { const sliceAngle = (item.value / total) * angleToDraw; if (sliceAngle > 0.01) { ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, currentAngle, currentAngle + sliceAngle); ctx.closePath(); ctx.fillStyle = colors[i % colors.length]; drawWithGlow(() => ctx.fill(), colors[i % colors.length]); currentAngle += sliceAngle; } }); ctx.font = '700 24px Manrope'; data.forEach((item, i) => { const itemProgress = Math.max(0, Math.min(1, (eased - i * 0.1) / 0.5)); if (itemProgress > 0) { ctx.globalAlpha = itemProgress; ctx.fillStyle = colors[i % colors.length]; ctx.fillRect(canvas.width * 0.05, canvas.height * 0.3 + i * 40, 20, 20); ctx.fillStyle = '#e0e7ff'; ctx.textAlign = 'left'; ctx.fillText(`${item.label}: ${item.value}%`, canvas.width * 0.05 + 30, canvas.height * 0.3 + i * 40 + 16); } }); ctx.globalAlpha = 1.0; }
function table(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); ctx.textAlign = 'center'; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.15); const headers = scene.tableHeaders || []; const data = scene.tableData || []; const area = { x: canvas.width * 0.1, y: canvas.height * 0.3, w: canvas.width * 0.8 }; const colW = area.w / headers.length; const rowH = 60; ctx.globalAlpha = Math.min(1, eased * 4); ctx.font = '700 24px Manrope'; ctx.fillStyle = '#38bdf8'; headers.forEach((h, i) => ctx.fillText(h, area.x + i * colW + colW / 2, area.y)); ctx.font = '400 22px Manrope'; data.forEach((row, ri) => { const rowProgress = Math.max(0, Math.min(1, (eased - 0.2 - ri * 0.1) / 0.5)); if (rowProgress > 0) { ctx.globalAlpha = rowProgress; ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fillRect(area.x, area.y + (ri + 0.5) * rowH, area.w, rowH); ctx.fillStyle = '#e0e7ff'; row.forEach((cell, ci) => ctx.fillText(cell, area.x + ci * colW + colW / 2, area.y + (ri + 1.2) * rowH)); } }); ctx.globalAlpha = 1.0; }
function drawP5Scene(scene, progress) { 
    const { ctx, canvas } = elements; 
    const p5Instance = p5Manager.getSketch(scene); 
    if (p5Instance && p5Instance.canvas) { 
        p5Instance.progress = progress; 
        p5Instance.draw(); 
        
        ctx.save();
        ctx.globalAlpha = easeOutCubic(progress); 
        
        // Ensure the P5 canvas is drawn within bounds
        const sourceWidth = p5Instance.canvas.width;
        const sourceHeight = p5Instance.canvas.height;
        
        // Calculate scaling to fit within target canvas while maintaining aspect ratio
        const scaleX = canvas.width / sourceWidth;
        const scaleY = canvas.height / sourceHeight;
        const scale = Math.min(scaleX, scaleY);
        
        const destWidth = sourceWidth * scale;
        const destHeight = sourceHeight * scale;
        const destX = (canvas.width - destWidth) / 2;
        const destY = (canvas.height - destHeight) / 2;
        
        ctx.drawImage(p5Instance.canvas, 0, 0, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
        
        ctx.restore();
        
        ctx.textAlign = 'center'; 
        ctx.font = '800 50px Manrope'; 
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; 
        drawWithGlow(() => ctx.fillText(scene.text, canvas.width / 2, canvas.height * 0.9)); 
    } 
}
function quiz(scene, progress) { const { ctx, canvas } = elements; const eased = easeOutCubic(progress); const sceneTime = progress * scene.duration; const narrationEndsTime = scene.narrationDuration + 500; const shouldReveal = sceneTime > narrationEndsTime; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const titleProgress = Math.min(1, eased / 0.2); ctx.globalAlpha = titleProgress; ctx.font = '800 50px Manrope'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText("Quiz Time", canvas.width / 2, canvas.height * 0.15); const questionProgress = Math.min(1, Math.max(0, (eased - 0.1) / 0.3)); ctx.globalAlpha = questionProgress; ctx.font = '700 36px Manrope'; ctx.fillStyle = '#e0e7ff'; const qLines = wrapText(scene.question, canvas.width * 0.8); qLines.forEach((line, i) => ctx.fillText(line, canvas.width / 2, canvas.height * 0.3 + i * 45)); const options = scene.options || []; const optionBox = { w: canvas.width * 0.4, h: 70, r: 10, gap: 20 }; options.forEach((opt, i) => { const optProgress = Math.min(1, Math.max(0, (eased - (0.3 + i * 0.05)) / 0.4)); if (optProgress <= 0) return; const isEven = i % 2 === 0; const x = canvas.width / 2 + (isEven ? -optionBox.w - optionBox.gap / 2 : optionBox.gap / 2); const y = canvas.height * 0.5 + Math.floor(i / 2) * (optionBox.h + optionBox.gap); ctx.globalAlpha = optProgress; let strokeStyle = 'rgba(255, 255, 255, 0.3)'; let glowColor = null; if (shouldReveal) { if (i === scene.correctAnswer) { strokeStyle = 'var(--correct-color)'; glowColor = 'var(--correct-color)'; } else { strokeStyle = 'var(--incorrect-color)'; } } drawRoundRect(ctx, x, y, optionBox.w, optionBox.h, optionBox.r); ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill(); ctx.lineWidth = 3; ctx.strokeStyle = strokeStyle; if (glowColor) { drawWithGlow(() => ctx.stroke(), glowColor, 15); } else { ctx.stroke(); } ctx.fillStyle = '#fff'; ctx.font = '700 24px Manrope'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillText(`${String.fromCharCode(65 + i)}: ${opt}`, x + 25, y + optionBox.h / 2); }); if (shouldReveal) { const answerProgress = Math.min(1, (sceneTime - narrationEndsTime) / 1000); ctx.globalAlpha = answerProgress; ctx.textAlign = 'center'; ctx.font = '800 32px Manrope'; ctx.fillStyle = 'var(--correct-color)'; drawWithGlow(() => ctx.fillText(`The correct answer is: ${scene.answerText}`, canvas.width / 2, canvas.height * 0.85), 'var(--correct-color)'); } ctx.globalAlpha = 1.0; }

// --- Preloading & Initialization ---
async function preloadAssets() { const { loadingText } = elements; loadingText.textContent = "Initializing Engine..."; await new Promise(res => setTimeout(res, 100)); loadingText.textContent = "Warming up Narration Voices..."; await new Promise(resolve => { speechSynthesis.getVoices(); setTimeout(() => { const voices = speechSynthesis.getVoices(); if (voices.length > 0) { state.maleVoices = voices.filter(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('male') || v.name.includes('David') || v.name.includes('Mark'))); state.femaleVoices = voices.filter(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('female') || v.name.includes('Zira') || v.name.includes('Samantha'))); if (state.maleVoices.length === 0) state.maleVoices = voices.filter(v=>v.lang.startsWith('en')); if (state.femaleVoices.length === 0) state.femaleVoices = voices.filter(v=>v.lang.startsWith('en')); resolve(); } else { speechSynthesis.onvoiceschanged = () => { const voices = speechSynthesis.getVoices(); state.maleVoices = voices.filter(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('male') || v.name.includes('David') || v.name.includes('Mark'))); state.femaleVoices = voices.filter(v => v.lang.startsWith('en') && (v.name.toLowerCase().includes('female') || v.name.includes('Zira') || v.name.includes('Samantha'))); resolve(); }; } }, 500); }); const urls = new Set(showcaseJson.scenes.flatMap(s => [s.bgUrl, s.imageUrl]).filter(Boolean)); if (urls.size === 0) return; let loaded = 0; const promises = Array.from(urls).map(url => new Promise(resolve => { const img = new Image(); img.crossOrigin = "anonymous"; const onFinish = () => { loaded++; loadingText.textContent = `Optimizing Asset ${loaded} of ${urls.size}...`; resolve(); }; img.onload = () => { state.images.set(url, img); onFinish(); }; img.onerror = () => { console.warn(`Failed to load: ${url}`); onFinish(); }; img.src = url; })); await Promise.all(promises); }
window.onload = async () => { try { let accumulatedTime = 0; showcaseJson.scenes.forEach(scene => { const wordsPerSecond = 2.2; const narrationDuration = (scene.narration.split(' ').length / wordsPerSecond) * 1000; scene.narrationDuration = narrationDuration; let duration = scene.duration || (narrationDuration + 2000); if (scene.type === 'quiz') { duration = Math.max(duration, narrationDuration + 4000); } scene.duration = duration; scene.startTime = accumulatedTime; accumulatedTime += scene.duration; }); state.totalDuration = accumulatedTime; await preloadAssets(); elements.loadingOverlay.style.opacity = '0'; setTimeout(() => elements.loadingOverlay.style.display = 'none', 500); elements.playPauseBtn.disabled = false; elements.statusEl.textContent = "Showcase is ready! Click the play button to begin."; createParticles(); draw(showcaseJson.scenes[0], 0); } catch (err) { elements.loadingText.textContent = "Error preparing showcase. Please refresh."; console.error("Initialization failed:", err); } elements.playPauseBtn.addEventListener('click', () => state.isPaused || !state.isRunning ? play() : pause()); elements.progressBar.addEventListener('click', seek); };
</script>
</body>
</html>